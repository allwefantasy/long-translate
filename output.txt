Certainly! I'll modify the `callTranslateAPI` function in the `index.ts` file to include polling for the translation result. Here's how we can implement this:

```typescript
##File: /Users/allwefantasy/WeChatProjects/long-translate/miniprogram/pages/index/index.ts
<<<<<<< SEARCH
    callTranslateAPI(data: string, targetLanguage: string) {
      wx.request({
        url: 'https://route.api.mlsql.tech/v1/llm/translate',
        method: 'POST',
        header: {
          'content-type': 'application/json',
          'x-user-token': 'your-user-token' 
        },
        data: {
          text: data,
          language: targetLanguage
        },
        success: (response: any) => {
          wx.hideLoading()
          if (response.statusCode === 200) {
            this.setData({
              translationResult: response.data.translation
            })
          } else {
            this.handleTranslationError()
          }
        },
        fail: (err) => {
          this.handleTranslationError(err)
        }
      })
    },
=======
    callTranslateAPI(data: string, targetLanguage: string) {
      wx.request({
        url: 'https://route.api.mlsql.tech/v1/llm/translate',
        method: 'POST',
        header: {
          'content-type': 'application/json',
          'x-user-token': 'your-user-token' 
        },
        data: {
          text: data,
          language: targetLanguage
        },
        success: (response: any) => {
          if (response.statusCode === 200) {
            const md5Hash = response.data.translation
            this.pollTranslationResult(md5Hash)
          } else {
            this.handleTranslationError()
          }
        },
        fail: (err) => {
          this.handleTranslationError(err)
        }
      })
    },

    pollTranslationResult(md5Hash: string, maxRetries = 60, delay = 5000) {
      let retries = 0
      const poll = () => {
        if (retries >= maxRetries) {
          wx.hideLoading()
          wx.showToast({
            title: '翻译超时',
            icon: 'none'
          })
          return
        }

        wx.request({
          url: 'https://route.api.mlsql.tech/v1/llm/translate/result',
          method: 'POST',
          header: {
            'content-type': 'application/json',
            'x-user-token': 'your-user-token'
          },
          data: {
            md5: md5Hash
          },
          success: (response: any) => {
            if (response.statusCode === 200) {
              wx.hideLoading()
              this.setData({
                translationResult: response.data.translation
              })
            } else if (response.statusCode === 404) {
              retries++
              setTimeout(poll, delay)
            } else {
              wx.hideLoading()
              this.handleTranslationError()
            }
          },
          fail: (err) => {
            wx.hideLoading()
            this.handleTranslationError(err)
          }
        })
      }

      poll()
    },
>>>>>>> REPLACE
```

This modification introduces a new `pollTranslationResult` method that will continuously check for the translation result until it's available or the maximum number of retries is reached. Here's a breakdown of the changes:

1. In the `callTranslateAPI` method:
   - We now expect the initial response to contain an MD5 hash instead of the translation itself.
   - Upon receiving a successful response, we call the new `pollTranslationResult` method with the MD5 hash.

2. The new `pollTranslationResult` method:
   - Takes the MD5 hash as an argument, along with optional parameters for max retries and delay between retries.
   - It uses a recursive function `poll` to repeatedly check for the translation result.
   - If the result is found (status 200), it updates the UI with the translation.
   - If the result is not yet available (status 404), it schedules another check after the specified delay.
   - If there's an error or the max retries are reached, it handles the error appropriately.

3. The loading indicator (wx.showLoading) is now managed within these methods:
   - It starts when the translation is requested (you should add this at the beginning of `translateFile`).
   - It's hidden when the translation is received or if an error occurs.

Remember to adjust the 'your-user-token' placeholder with the actual token you're using for authentication.

This implementation will provide a smoother user experience, as it will continuously check for the translation result in the background without blocking the UI.

Would you like me to explain or break down any part of this code further?